var documenterSearchIndex = {"docs":
[{"location":"intro/#PopDyLan.jl-Documentation-1","page":"Home","title":"PopDyLan.jl Documentation","text":"","category":"section"},{"location":"intro/#","page":"Home","title":"Home","text":"PopDyLan.jl is a Julia package for exploring the population dynamics of language through agent-based simulations.","category":"page"},{"location":"intro/#","page":"Home","title":"Home","text":"note: Note\nPopDyLan.jl is currently in development, awaiting a first stable release. Use at your own risk.","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Usage examples go here...","category":"page"},{"location":"methods/#Methods-1","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"methods/#Introduction-1","page":"Methods","title":"Introduction","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"Methods (functions) operate on types, producing an output or modifying their inputs (or, sometimes, not doing anything at all). Names of methods that (may) modify their arguments end, per Julian conventions, in an exclamation point.","category":"page"},{"location":"methods/#","page":"Methods","title":"Methods","text":"Note that, in contrast to actual object-oriented languages such as C++ where objects own their methods, in Julia this is not the case. For instance, to make speaker A to listen to speaker B, we use something like","category":"page"},{"location":"methods/#","page":"Methods","title":"Methods","text":"listen(A, B)","category":"page"},{"location":"methods/#","page":"Methods","title":"Methods","text":"rather than","category":"page"},{"location":"methods/#","page":"Methods","title":"Methods","text":"A.listen(B)","category":"page"},{"location":"methods/#Reference-1","page":"Methods","title":"Reference","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"listen!(x::VL, y::VL, a)","category":"page"},{"location":"methods/#Main.PopDyLan.listen!-Tuple{VL,VL,Any}","page":"Methods","title":"Main.PopDyLan.listen!","text":"listen!(x::VL, y::VL, a)\n\nMake learner x listen to learner y with grammatical advantages a. Learner x's state is (potentially) updated if the learner is plastic. Learner y's (the speaker) state is not modified.\n\n\n\n\n\n","category":"method"},{"location":"types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Introduction-1","page":"Types","title":"Introduction","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"In PopDyLan.jl, important data structures are given their own types. Thus, there is a type for a speaker, a type for a speech community, a type for a grammar, etc. These are referenced below, categorized into linguistic types (types for grammars, parameter settings, and the like), individual types (types for representing individual speakers) and population types (types for speech communities).","category":"page"},{"location":"types/#Reference-1","page":"Types","title":"Reference","text":"","category":"section"},{"location":"types/#Linguistic-Types-1","page":"Types","title":"Linguistic Types","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"VL","category":"page"},{"location":"types/#Main.PopDyLan.VL","page":"Types","title":"Main.PopDyLan.VL","text":"Variational Learner (1-parameter)\n\n\n\n\n\n","category":"type"},{"location":"types/#Individual-Types-1","page":"Types","title":"Individual Types","text":"","category":"section"},{"location":"types/#Population-Types-1","page":"Types","title":"Population Types","text":"","category":"section"}]
}
